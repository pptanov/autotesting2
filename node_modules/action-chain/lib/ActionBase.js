"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var StopExecution = /** @class */ (function () {
    function StopExecution(value) {
        this.value = value;
    }
    return StopExecution;
}());
exports.StopExecution = StopExecution;
var ActionBase = /** @class */ (function () {
    function ActionBase(actionChain, initialActionId, runOperators) {
        if (initialActionId === void 0) { initialActionId = ActionBase.nextActionId++; }
        var _this = this;
        this.actionChain = actionChain;
        this.initialActionId = initialActionId;
        this.runOperators = runOperators;
        this.currentExecutionId = 0;
        this.createOperatorResult = function (type, name, cb) {
            return [
                _this.actionChain,
                _this.initialActionId,
                function (props, executionContext, newPath) {
                    var executionContextWithPath = {
                        __execution: executionContext.__execution,
                        __path: newPath
                            ? executionContext.__path.concat(newPath)
                            : executionContext.__path.slice(),
                    };
                    var prevResult = _this.runOperators
                        ? _this.runOperators(props, executionContextWithPath)
                        : props;
                    var produceResult = function (currentValue) {
                        if (currentValue instanceof StopExecution) {
                            return currentValue;
                        }
                        var thisExecution = tslib_1.__assign({}, executionContextWithPath.__execution, { operatorId: executionContextWithPath.__execution.operatorId + 1 });
                        executionContextWithPath.__execution.operatorId++;
                        var path = executionContextWithPath.__path;
                        var effects = Object.assign({}, _this.actionChain.getEffects(thisExecution), executionContextWithPath);
                        _this.actionChain.emit('operator:start', tslib_1.__assign({ type: type,
                            name: name,
                            path: path }, thisExecution));
                        var result = cb(effects, currentValue);
                        if (result instanceof Promise) {
                            _this.actionChain.emit('operator:async', tslib_1.__assign({ type: type,
                                name: name,
                                path: path, isAsync: true }, thisExecution));
                            return result.then(function (promiseResult) {
                                _this.actionChain.emit('operator:end', tslib_1.__assign({ type: type,
                                    name: name,
                                    path: path }, thisExecution, { isAsync: true, result: promiseResult }));
                                return promiseResult;
                            });
                        }
                        _this.actionChain.emit('operator:end', tslib_1.__assign({ type: type,
                            name: name,
                            path: path }, thisExecution, { isAsync: false, result: result }));
                        return result;
                    };
                    if (prevResult instanceof Promise) {
                        return prevResult.then(produceResult);
                    }
                    return produceResult(prevResult);
                },
            ];
        };
        this.getActionChain = this.getActionChain.bind(this);
        var instance = Object.assign(function (value) {
            var initialOperator = typeof arguments[1] === 'undefined';
            var newPath = typeof arguments[2] === 'undefined' ? null : arguments[2];
            var executionContext = initialOperator
                ? {
                    __execution: {
                        operatorId: -1,
                        actionId: initialActionId,
                        executionId: instance.currentExecutionId++,
                    },
                    __path: [],
                }
                : arguments[1];
            if (initialOperator) {
                actionChain.emit('action:start', {
                    actionId: executionContext.__execution.actionId,
                    executionId: executionContext.__execution.executionId,
                    actionName: instance.displayName,
                    value: value,
                });
            }
            var returnValue = runOperators
                ? runOperators(value, executionContext, newPath)
                : value;
            if (initialOperator && returnValue instanceof Promise) {
                returnValue.then(function () {
                    actionChain.emit('action:end', {
                        actionId: executionContext.__execution.actionId,
                        executionId: executionContext.__execution.executionId,
                        actionName: instance.displayName,
                    });
                });
            }
            else if (initialOperator) {
                actionChain.emit('action:end', {
                    actionId: executionContext.__execution.actionId,
                    executionId: executionContext.__execution.executionId,
                    actionName: instance.displayName,
                });
            }
            return returnValue;
        }, this);
        return instance;
    }
    ActionBase.prototype.getActionChain = function () {
        return this.actionChain;
    };
    ActionBase.nextActionId = 0;
    return ActionBase;
}());
exports.ActionBase = ActionBase;
//# sourceMappingURL=ActionBase.js.map